-------------------------------- 2023-05-09 --------------------------------

Los datos fueron modificados: 
  * FWI es constante entre incendios (vuela de los paisajes y de los parámetros)
  * elevation va estandarizada, y se tiene que estandarizar la distance para 
    calcular la slope
  * la vegetación es una integer matrix, codificando de 0 a k, con 
    99 == non-burnable
  
  * incluir en los datos los 2 dry forests y la estepa. La reclasificación
    se dará al asignar los mismos parámetros, por ejemplo, a shrubland y steppe.


Editar código de prior predictive checks para que use los nuevos datos.
# DONE, pero queda editar la parte en que explora las similarities.

Editar similarity metric selection.R

Hacer funciones para flexibilizar los códigos de vegetación.
En muchos paisajes va a haber pocos vegetation types. Algunos estarán ausentes
y otros serán tan poco abundantes que será sensato directamente asumirlos
ausentes (pensar bien el criterio en base a su abundancia absoluta o relativa**).
En ambos casos, la forma de "ignorarlos" es hacer que su intercept sea igual
al de otra vegetation type. Entonces, necesitamos recodificar todas las veg
types funcionalmente ausentes.

Lo ideal sería indicar qué tipos de vegetación vas a considerar/usar, y que 
en base a eso sepa cómo sinonimizar los demás. 
Entonces, si voy a usar 
  shrubland, dry_b
la función debería convertir los demás parámetros de veg a estas clases, 
siguiendo un orden de preferencia como la siguiente (chequear mirando análisis 
de patrones):

  shrubland: dry_b, steppe, dry_a, wet, subalpine;
  subalpine: wet, dry_a, dry_b, shrubland, steppe;
  wet:       subalpine, dry_a, dry_b, shrubland, steppe;
  dry_a:     subalpine, wet, dry_b, shrubland, steppe;
  dry_b:     shrubland, dry_a, wet, subalpine, steppe;
  steppe:    shrubland, dry_b, dry_a, wet, subalpine;

Ejemplo:
si en un paisaje tengo solo
  dry_a, 
  steppe, 
debería hacer estas conversiones:
  subalpine: dry_a,
  wet:       dry_a, 
  dry_b:     dry_a
  shrubland: steppe

El vector de intercepts, cuyo orden es
{shrubland, subalpine, wet, dry_a, dry_b, steppe}
quedaría
{steppe, dry_a, dry_a, dry_a, dry_a, steppe}

** Criterio de escasez para ignorar veg types:
- Area menor al 1% del paisaje quemable efectivo (es decir, descontando
  islas de quemable no conectadas con el punto de ignición) 
  OR
- Área < 100 píxeles.

Problemas de criterios areales: a veces un área muy pequeña puede tener 
efectos importantes. 
Ejemplo: el fuego empieza en un parchecito de subalpine, donde hay baja flamm.
Se hace muy peque hasta extinguirse sin llegar al matorral. En cambio, 
si empieza en matorral, aunque sea pequeño el parche, logra quemar un 
número de píxeles suficientemente grande como para quemar el subalpine que 
rodea al matorral.
Si creemos que las condiciones iniciales son muy importantes, entonces esto 
también debería definirse según la distancia al punto de ignición.
  
Antes de complicarme con esto, mejor evaluar bien cuántos veg_types hay por 
paisaje y su abundancia relativa. Quizás es muy evidente si hace falta quitar 
clases o no, y hasta podría hacerse a ojo.




---- TAREAS PARA MÁS LUEGO

- Elegir la métrica de similitud 
- Volver a descargar todos los paisajes con las clases de vegetación completas
  (dry forests separados), y hacer paisajes para R con las 6 clases (incluye
  estepa).
- Editar códigos de waves para que "ignore" los veg types ausentes o escasos.
- Analizar en GEE la abundancia de cada veg type (6) en paisajes y en incendios,
  para todos los fuegos (ig point known y unknown)
  
  
  
  
---- CONSIDERACIONES RANDOM EFFECTS --------------------------------- 
  
En vez de ajustar un modelo de loglik para cada fuego, quizás convenga
modificar a mano los intercepts y el sd de los random effects para 
que se ajuste bien a todos los incendios, asumiendo que la likelihood de los
demás parámetros casi no va a cambiar, ya que son incendios pequeños
que informan poco. 

Se pueden ajustar modelos de tipo 
raneff ~ fire size, 
(usando todas las muestras de la posterior de incendios con ig conocido)

luego predecir estocásticamente el raneff de los fuegos no usados
y evaluar qué media y sd ajusta bien a todo el set de incendios completo. 

A posteriori, podemos usar la relación entre fire size e intercept para
estimar el punto de ignición, muestreando intercepts de ese modelo.  
 
En fin, quizás no sea necesario ajustar los 210 MVN models, sino 51.


----
Otra: si los MVN son muy lentos como para ajustar a 210 datos, podemos
usar GPs y poner dos umbrales para la parte de rechazo de partículas:
1) el e_j propuesto tiene que superar el umbral del borde del terreno;
2) si pasa ese filtro, e_j tiene que ser mayor a un umbral deseado.

El primer filtro evita evaluar el GP cuando el GP queda out of bounds. 
Esto requeriría guardar un GP (likelihood) y un GAM (in_bounds_model) 
por incendio, pero no me parece mal. 

Estudiar cómo sería un gibbs sampler para un modelo como el mío.


___ USAR GIBBS!!!

Yo me preocupaba por que la likelihood estuviera truncada de abajo, 
pero una forma muy simple de resolver eso es usar el GP completo y 
rechazar las partículas que tienen una like < lower_limit + delta

Supongamos que lower_limit = 0.05 es el overlap del incendio más grande.
delta podría ser algo así como 2Sigma del GP cuando está fuera de bounds.

Para asegurarnos de nunca estar cerca de ese borde, al momento de 
samplear random intercepts, hacemos lo siguiente:

01) proponemos un alpha_star de la distrib de propuestas
02) sorteamos si está in_bounds con el in_bounds_gam
03) evaluamos su like con el GP, = like(alpha_star)
		(en este paso, simulamos con el GP, para considerar la 
		 uncertainty del metamodelo)
04) la conservamos si like(alpha_star) > lower_limit + delta
05) alpha_i = sorteo(alpha_star, alpha_i-1) tipo metropolis.

Otra forma más simple sería sin usar el in_bounds_gam, 
simplemente rechazando todo lo que esté > lower_limit + delta.
Pero seguramente usar el gam disminuiría la tasa de rechazo.

Este artilugio sería como un truncamiento de la likelihood function 
en la dimensión del intercept. Como no podemos ver cuánto le erramos 
a la verdadera similarity porque el paisaje nos restringe, sabemos
que es baja y la igualamos a cero. Esto afectaría principalmente 
a la incertidumbre sobre cada intercept, y no tanto a la incertidumbre
sobre los hiperparametros.

Para el punto de ignición podemos hacer exactamente lo mismo, y estimarlo
de forma discreta. luego, agregamos un filtro similar al que tenemos
para el intercept:
	nos fijamos si el pixel propuesto está en el incendio
	si está, seguimos, evaluando la likelihood y todo; si no, 
	probamos con otro.




